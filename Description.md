# Описание работы программы
## Этап настройки

1. Пользователь выбирает области анализа
    - Устанавливаются border_line_x, border_line_y
    - Отрисовывается перекрестие на картинке
2. Пользователь выбирает зону, в которой будут расчитываться контуры объектов, путем установки вертикального смещения
    - Устанавливается offset_y
    - Отрисовываются розовые линии на картинке
3. Пользователь кликает по той стороне картинки (относительно вертикальной линии), на которой машины движутся НА камеру
    - Устанавливается флаг great_britain=True, если пользователь кликнул левее вертикальной линии
4. Ожидание нажатия любой клавиши, что продолжит работу основной части программы

## Этап тренировки вычитателя фона
Для выделения движущихся объектов на кадре используется алгоритм MOG2, а конкретно его реализция
`BackgroundSubtractorMOG2`
 
Для наилучших результатов его необходимо сначала "научить", так как он использует информацию о фоне, обрабатывая предыдущие кадры

На этом этапе мы скармливаем ему первые 500 кадров

А затем перезапускаем получение видео

Этот этап достаточно долгий.

## Работа программы
Весь процесс работы программы можно разбить на 3 этапа, которые выполняются над каждым* кадром
1. Поиск объектов на изображении
    - На вход подается кадр из видео
    - На выходе получаем массив контуров
    - В нашем конкретном случае на выходе еще передается изображение - результат работы алгоритма, 
      по которому ищем контуры
2. Определение путей движения контуров и подсчет автомобилей
    - На вход принимаются контуры
3. Вывод информации на экран
    - Рисует статистику на кадре, для показа пользователю
    
\* - этап поиска контуров выполняется для каждого третьего кадра, во имя производительности

Отдельно рассмотрим первый и второй этапы

### Выделение контуров
Кадр обрабатывается по следующему алгоритму:
1. Удаляем фон с помощью вычитателя фона

    `fgmask = self.bg_substractor.apply(frame)`
    
    Полученная маска достаточно шумная, на ней много несвязанных контуров
2. Выполняем морфологические операции над маской, чтобы убрать шум и получить четкие связанные контуры
    
    Эту операцию можно сделать несколькими способами, и именно от нее зависит качество нахождения контуров
    1. Последовательное использование операций замыкания и размыкание контуров
        ```
            # Закрытие контуров
            # closing = cv2.morphologyEx(fgmask, cv2.MORPH_CLOSE, kernel)
            # Удаление шумов
            # opening = cv2.morphologyEx(closing, cv2.MORPH_OPEN, kernel)
        ```
    2. Пороговое отсечение для удаления теней
    
        `ret, thresh = cv2.threshold(er2, 127, 255, cv2.THRESH_BINARY)`
        
    3. Валидация полученных контуров
        ```
        # Ограничение области распознавания
        for i, cntr in enumerate(contours):
            x, y, w, h = cv2.boundingRect(cntr)
            if ((2 * y + h)/2 >= self.border_line_y_top and (2 * y + h)/2 <= self.border_line_y_bottom) & (cv2.contourArea(cntr) >= self.contour_area_limit):
                valid_cntrs.append(cntr)
        ```
    
        На этом этапе удаляются контуры, чья площадь меньше допустимого размера
        
        А также те контуры, чьи центры не попали в область распознавания
        
    4. Возвращаем контуры

### Определение путей движения и подсчет автомобилей

Для определения путей движения контуров каждому из них присваивается ключ

Для этого используется словарь, в котором для каждого ключа существует путь (до 10 точек центров контуров)

Для каждого из новых контуров мы ищем ближайший из уже известных.

В случае, если такого нет, мы создаем новый путь с новым ключом.

Если ближайший найден, мы добавляем в путь новый контур.

При этом проверяем, пересекает ли данный путь линию подсчета `border_line_y`

Если пересекает, то считаем, учитывая предполагаемое направление движения 
(слева или справа от `border_line_x`)

Значения счетчиков получаем, обращаясь к экземпляру класса

### Отображение результатов на изображении
В зависимости от режима (отладка или нет) отрисовываем необходимую информацию
